   ┌───────────────────────────┐
┌─>│           timers          │  setTimeout setInterval 对应的回调函数
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks   x │  本次没有执行完下次执行的回调 ， 这里没法控制
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare     x │  系统内部用的回调队列
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │  事件触发线程 在轮训的过程中会在这里阻塞  （1.执行异步i/o回调） （2.监控时间到了，回到timer中）
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │ setImmediate 回调在这里
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks    x │ 关闭时的回调 socket.on('close',()=>{})   ...
   └───────────────────────────┘


- 默认事件环依旧是先执行主栈代码 （产生的宏任务任务，和浏览器一样 （这里会放到不同的队列中））


- 主栈执行完毕后，会扫描timers中是否有回调，如果有回调，则会取第一个来执行 （宏任务每次执行一个）  每次清空一个阶段后执行下一个
- 如果没有定时器，则进入到poll阶段，此时会执行i/o操作的回调，如果有则取出一个来执行 （如果poll清空了）此时会检测是否有涩图Immediate的回调，如果有则执行，没有就等待
- 等待定时器到达时间后 在重回timers 阶段，或者有i/o事件完成，去执行回调

- 主栈 -》 timers -》 poll -》 check -> timer
- 主栈 -》 timers -》 poll -》 timer
- 主栈 -》 timers -》 poll
- 微任务其实和浏览器一样 promise.then process.nextTick (也是一个异步api) 在当前代码执行完毕后会优先于 promise.then来执行
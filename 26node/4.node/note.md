## node是什么？ 能做什么？
node 不是一门语言， 一个运行时 （运行环境） js的组成部分（ECMASCript, BOM DOM） 在node中只包含 (ECMASCript, node中还内置了一些模块，这些模块可以帮我们实现对应的功能 + 别人写好的模块 第三方模块)  node运行的js 依旧保留js的特性，主线程是单线程的

## 单线程 & 多线程
- 多线程：每次请求到来的时候 都需要单独的开启一个线程来处理请求 （多线程的好处 就是多个请求到来时，可以同时的处理）多线程比较适合cpu密集型 （压缩，计算、加密） 后面的逻辑不需要等待前面的处理 （多线程的缺陷，就是会可浪费内存 采用线程池） 如果多个线程同时操作一个资源 （锁）。 所谓的同时进行
- 单线程： 第一个请求到来的时候我们采用主线程来处理，同时第二个请求到来了，需要等待第一个处理完毕后才能处理 （比较适合i/o） web应用中，比较多的都是文件操作 （静态资源 nginx 单线程模型） 也不涉及到多个线程操作一个资源 也没有锁的概念


多线程适合cpu密集型(同步的 阻塞)   单线程适合i/o密集型(异步的 非阻塞)

阻塞和非阻塞 指代的是调用方的状态， 同步异步 指代的是被调用方的状态


同步阻塞  异步非阻塞（回调的方式 fs.readFile）   同步非阻塞      node中主线程是单线程的，但是底层 libuv 基于的是多线程模型 （eventLoop） node也支持多进程

> 异步、非阻塞、基于事件


## node的未来？
- 工具： gulp 、 webpack、 rollup 、 vite （node来实现、因为前端学的容易） 为前端工程化来服务 
- 服务端渲染 ssr （vue / react  seo优化）  node天生支持js 所以可以用node来解析 vue和react达到服务端渲染的目的 （预渲染插件）
- bff 中间层 、 用它来做服务端 （为前端提供服务端后端） 可以解决跨域问题  （数据格式化， 请求代理， 调用微服务等等）

> 因为node 用的是js ， 所以很容易上手， 通过node可以让前端更加了解后端


## 最需要先掌握的是node中的模块机制
- 为什么要有模块？ 命名冲突, 依赖模块 （为了方便复用，维护方便， 高内聚 低耦合） 前端解决模块问题 1） 单例模式  2) 自执行函数  3) requirejs seajs esModule (export import)    systemjs(jsop回调实现)  浏览器的模块化实现 需要基于请求 
- node中的模块处理  commonjs 规范 (来描述模块怎么使用)
    - 任何一个js文件都是一个模块 （每一个文件都是模块）
    - let Promise = require('./promise') 同步的引入  node中会读取某个文件 拿到内容实现模块化
    - module.exports = xxx 我想让别人用我自己


## 先掌握内置的一些模块 
- fs  filesystem 操作文件都需要用这个模块
- path 路径处理
- vm 运行代码


## 去用这些api实现一个commonjs规范
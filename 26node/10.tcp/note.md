## 七层分别是哪七层

> 每一层做了哪些事情

- 应用层 用户最终看到的 **报文**
- 表示层 表示数据的方式， 压缩
- 会话层 建立会话 和管理会话的

--------上面三层在使用的时候会被合并到一层--------

- 传输层 传输数据的，数据丢了怎么办？ 重传？数据是否可靠传输 传输数据 **数据段** 端口号，拆分数据 （传输层会对数据进行拆分和分割）
- 网络层 寻址 （定位到对方）**数据包** 就是添加原地址和目标地址

--------物理层----------

- 数据链路层 建立逻辑连接，将数据进行封装传递过去 （**帧** 1500 字节 MTU 最大的传输单元）将数据传递给对方（中转）
- 物理层 （物理设备 主要在计算机中就是如何传递二进制数据， 电线，同轴电缆，无线，双绞线） 传输 0 和 1 物理设备

> 底层是为上层服务端的

## ip 地址 mac 地址

- 网址——》 ip 地址 网址好记 -》 ip 地址不好记
- ip ipv4 192.168.1.1 (255.255.255.255) 不够用，子网的划分 ipv6 由 8 个 16 个位组成的地址 ip（短） 所谓的寻址就是寻找 mac 地址
- mac 网卡和网卡的通信（mac 地址) 一般情况下 mac 地址是唯一的 通过 mac 地址来交换数据 （长）

## 局域网如何通信

- 物理层 中继器 **两口** （实现信号再生）通过中继器实现信号的放大，解决最大传输问题
- 物理层 集线器 **多口** 可以实现多台设备交互 （广播的形式发发送数据，不会帮你过滤敏感信息）
- 数据链路层 交换机 （记录端口和 mac 地址的关系） 我们通信通过 ip 地址获取对方的 mac 地址 有了 mac 地址之后 可以拿到对应的端口实现通信

## 外网（路由器 网关）

路由器有两张网卡 一个网卡和局域网通信 ，另一个负责链接外网 (如果没有 wan 的路由器其实就可以看成交换机)
路由器网卡可以将 ip 地址转换成外网地址，并且可以增加对应端口来识别物理设备的身份

## 协议 （第三层开始才有协议）

- 应用层 http （应用层协议） 协议 DNS（将网址转换成 ip 地址） DHCP 动态主机配置协议
- tcp （面向连接，安全可靠慢） 、 udp（非连接 不安全不可靠 快）
- ip 协议 寻址的， arp 协议（也有人称之为链路层的协议） （下两层不具备协议，所以把 arp 就算到 ip 层上）

## tcp 的特点及组成格式

（tcp 是一个全双工的 单工、半双工（同时只有一个人在说话）、全双工）
三次握手和四次断开 缺陷和优点

- 三次握手的目的 就是建立双向的链接 （实现了双方可以建立连接）

  - 1. 我可以和你发短信么
  - 2. 好的， 那我可以给你发消息么
  - 3. 可以呀

- 四次断开是如何来的？
  - 1. 我们分手吧！
  - 2. 我收到了， （女生不能立刻发起分手的动作）
  - 。。。。 正在发送其他消息
  - 3. 我们分手吧
  - 4. 对方确认 分手吧~

> 缺陷：tcp 每次传输一个数据段的时候 都要增加一个 20 字节的头部 （粘包）

### 1.握手的流程

- 客户端和服务端分别有一个序列号 seq = 0

客户端我的序列号是 0 seq = 0， 服务端要表示我收到了这个数据做应答 ack = 客户端 seq + 1, 并且告诉客户端服务端的 seq 是多少 seq = 0, ack = 1

客户端会收到 客户端的 ack = 服务端 seq + 1 ， 服务端响应给客户端的 ack 或作为客户端的 seq

> 握手后 ack = 1 seq = 1 (两个序号分别是客户端的序号和服务端序号的)

### 2.发送消息的过程

客户端和服务端说 hello -》 服务端要立刻响应

客户端的 seq=1 , ack 的值也是 1 长度为 5 个字节的大小的内容
服务端响应 ack = 客户端的 seq + len, 我的序号还是 seq = 1

服务端和客户端说 hi -》 客户端要响应

服务端的序列号是 seq= 1 , 我的 ack = 6， len = 2 我要发送两个字节的消息
客户端就收到消息要响应 ack = 服务端的 seq + 服务端的 len， 我的序号是是上次服务端 aqck 的值 seq = 6

> tcp 如果发现对方没有响应，会认为数据丢失了 ，会重新发送

### 3.断开也是双方的基础上+1



## 三次握手和四次断开的时候
- 当断开的时候， 客户端最后发送的确认消息，服务端可能收不到 （服务端如果认为丢包了，会再次发送分手消息） 客户端不能再发送分手确认消息后立刻断开，如果断开会报异常 （客户端发送确认消息后，需要等待一段时间）
- 每次断开的时候都不能立即断开，导致端口无法释放，可能导致端口用尽 （http基于tcp，http1.0最早的时候短链接，用完tcp后就断开，http1.1 keep-alive 所谓的长连接，可以再1个tcp 通道中多次传输数据）

- 在发送数据的时候 发送方有对应的缓存区，对方有接受的缓存区， 在创建tcp连接的时候 会进行窗口协商， 自动的会更新窗口大小
- 流量控制 （滑动窗口，当队头的tcp段发送过去并且确认了，才会滑动） 这里会发生阻塞情况，除了队头的收到了，也不能发送其他数据（tcp的队头阻塞问题，无解的）  tcp每个数据段都标识了 seq
- 如果接收方的缓存区满了，会主动告诉发送方调整窗口大小为0.如果接收方的数据被上层应用读取，读取后会主动通知发送方，如果接收方发送的数据丢包了，不用担心，发送方会定时发送探测包，来监控接收方的窗口大小
- 如果发送的数据，可以立刻被接收方确认，那么可以无线的发送数据吗? (带宽) 如何计算拥塞窗口大小 （慢启动 慢慢开始） 最浪费时间，http中默认可以同时在一个域名下 开启6个tcp的链接 （经历6次的慢启动，如果中间丢包了，也会出现从0开始） （用快重传来达到减少慢启动的过程）


> 缺点：（端口占用问题，慢启动问题  keep-alive）， tcp队头阻塞问题 （解决有序传输)  有点：有序，可靠，快重传，粘包  nagle算法 （默认只有一个小的段在传输），cork算法  （粘包的目的就是为了解决减少tcp段数据较小的问题）


## http1.1
(在1个tcp链接中)我们的http不能同时发送多个请求，因为响应的时候 对不上 （http请求是没有seq, 无状态的）对头阻塞 （浏览器默认不开启管线化，不开启  啥叫管线化，是一种想法就是在一个tcp中批量提交多个http请求，但是响应要按照顺序应用） 响应要按照请求的次序来响应
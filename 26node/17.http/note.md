## HTTP1.0 (底层基于tcp协议)
- 没有所谓的长链接，每个请求都会创建一个tcp链接 （三次握手、四次断开，慢启动、每次断开的时候客户端是出于time-await 不能立刻断开，占用端口导致端口用尽最大限制65535）

## HTTP1.1
- keep-alive （不断开链接，尽可能复用链接） 我们可以再一个tcp链接中发送多个http请求 （content-length） 对请求的分割。 请求和响应都是1:1对应的，请求都是串行的 （队头阻塞 head-of-line-blocking） 管线化浏览器默认不启动（可以同时在一个管道tcp，中同时整批提交http请求，无法解决队头阻塞问题） 1个域名我们可以开启（6）个tcp链接 （经历6次慢启动，竞争带宽） （可以解决并发问题） 如果多增加域名（域名多了需要做dns解析，浪费性能） 文件我是尽可能的小，还是尽可能的合并？  优化：雪碧图、文件尽可能合并、减少请求。 如果都合并了会导致缓存问题、下载慢、 压缩、 静态文件的优化就是cdn (内容分发网络，核心就是找最近的服务商底层原理就是dns解析) 

- 优点：keep-alive，内部cookie  缺点：http请求导致队头阻塞问题， header没法压缩，不安全（明文，可能内容被篡改）
    - 为什么不能再一个tcp链接上并发请求？ http无序，响应就不知道哪个对应哪个了，假如我们同时请求js 和 css 如果是并发的那么响应css 对应的css无法创建这样的关联 （1个文件非常大，数据在接收后无法重组）


## HTTPS来解决问题
- https = http + ssl/tls 目前都叫tls 不叫ssl了 （核心就是将数据进行加密）
- 防止传递的数据被篡改 签名

### 1) 如果让数据实现加密 
- 加密算法（能加密、能解密） 对称加密 AES (一把钥匙可以加密也可以解密)  非对称加密 RSA （两把钥匙 公钥 私钥）

    - 1.客户端主动去像服务端获取密钥，服务端返回密钥，之后进行通信（密钥要先在网络传递一次，可能被劫持了） 不可靠

    - 2.非对称加密（服务端产生两把钥匙，分别是公钥和私钥，将公钥发给客户端） 客户端发送消息的时候 通过公钥加密，服务端通过私钥解密。 中间有可能公钥被劫持了，但是公钥无法解密内容 （单向） 如果想实现双向？ 分别两方都有一对钥匙

    - 3.非对称加密性能不好。 考虑用两种加密方式来实现， 第一次我们通过非对称加密，让服务端把自己的公钥交给客户端 （公钥不怕劫持，因为劫持到公钥是无法解密的），客户端生成一个会话密钥（随机值） 用服务器的公钥加密这个随机值（只能服务端解密），服务端收到加密后的内容，进行解密拿到了这个随机值 （双方都有了一个随机值了）后面可以通过对称加密通信。 第一次你访问服务端的时候可能访问的不是真正的服务端（中间商）

    - 4.通过证书来确定对方的身份是正确的 （找个公安局，发个身份证 ，我就知道我是我了）  给公钥增加认证


    - 5.通过证书让公钥变得可信任，客户端像服务端要证书，服务端通过ca机构(ca机构有两把钥匙 公私钥)生成一个证书  （服务器：公钥，过期：xxx） 。 将生成的证书通过ca机构的私钥来进行加密，发送给客户端。客户端收到证书后（内置了ca机构的公钥，可以解密），这样就可以顺利的拿到对方的公钥，而且能确定对方身份

    - 问题在于证书比较大，直接私钥加密，公钥解密浪费性能。 我们将证书进行摘要（摘要的结果很短）用ca的私钥对这个摘要进行加密。 客户收到后会采用摘要算法对内容再次进行摘要，用内置的ca机构的公钥解密出摘要的结果。 看一下两个摘要是否一致，一致说明内容没有被篡改 
    > 为了解决直接加密证书的问题，就变成了对证书进行摘要，再将摘要的结果私钥进行签名。客户端采用公钥来解密签名。获得了证书的摘要结果。再次对证书的内容进行摘要，如果摘要结果一致，则说明证书可信


> 整个https的过程就是  先采用非对称加密，来传递公钥，之后通过对称加密来进行痛惜。



### 2） https 抓包的流程 Diffie-hellman (在不交换密钥的情况下，可以协商出来一个密钥)
 - 客户端和服务端主动握手 产生了一个随机数 clientRandom
 - 服务端握手 产生一个随机数 serverRandom
 - 服务端发送个证书 ， 同时产生一个dh参数 （是为了加密算法使用的）
 - 客户端也生成一个 dh参数


 客户端/服务端： 服务端的随机参数 + 客户端的随机参数  客户端的clientParms 服务端的serverParams  = 会话密钥


 中间人也知道这些参数 （为什么中间人无法拦截到这个密钥） = ？会话密钥


 不安全Diffie-hellman 

 A                  B
 A自己的密钥          B自己的密钥 
 创建了一个参数给了B  创建了一个参数给了A

用B的参数加上A的密钥    用a的参数加上b的密钥

预主密钥        ===      预主密钥


https  对称加密 AES 非对称加密 RSA  证书的目的是验证身份（摘要算法sha256 来验证证书是正确的） 协商密钥（Diffie hellman） 协商出一个会话密钥，最终通信


都可以 不可以公钥加密 公钥解密   服务端发送公钥给客户端 （中间商只能拿到公钥）

中间人可以拿到证书 ， 拿到证书如何修改呢？  签发者？   



## http1.1 的问题
- 我们可以再一个域名下建立6个tcp链接（为了实现并发 ， 会导致有6次慢启动， 带宽竞争问题）因为http没有序号
- header是不会被压缩的
- http1.1 没法乱序收发的（1个tcp链接上）



## http2
- 我们一个域名只建立一个tcp链接， 在一个tcp链接中实现数据的收发。 给数据标号（类似tcp的seq）
- http2 采用了多路复用， 可以将数据编程帧进行传输 （以前http1.1 有队头阻塞问题， http2 请求不用等待 可以并发发送） 流、帧
    > 流是虚拟的， 真正传输的叫帧
- http2 中实现了这样一个分帧层，可以实现流量控制、优先级控制。 支持了服务端推送 （1.1应答模式）
- 头部压缩  静态表 替换相同的内容 为数字  动态表，比较两次header的差异 只发送差异的部分  哈夫曼编码（哈夫曼树 左树为0  右树为1） 核心 就是用出现少的数编码采用长的，出现多的数 编码用短的

> 缺点：我们解决的永远是http层面的，但是服务端在处理的时候 还是 tcp（队头阻塞问题） 无法解决的 -》 http3 采用了udp协议

如何将字符编译成二进制？  ABCD
A 00
B 01
C 10
D 11
E 110
F 100
g 110101011
.....
00011011


_ 00
D 01
E 0110


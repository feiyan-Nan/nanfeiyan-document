<!doctype html>
<html lang='en'>
<head>
  <meta charset='UTF-8'>
  <meta content='width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0'
        name='viewport'>
  <meta content='ie=edge' http-equiv='X-UA-Compatible'>
  <title>Document</title>
  <style>
    #box:active {
      background: red;
    }
  </style>
</head>
<body>
<div id='box'></div>
<script type='text/javascript'>
  //   1、闭包，this
  //   2、作用域
  //   3、Array判断方法有哪些？
  //   4、typeof instanceof区别
  //   5、Promise状态有哪些
  //   6、手写promise.then()、promise.all()
  //   7、cookies，localStorage，sessionStorage区别
  //   8、eventloop描述出整个过程
  //   9、手写new
  //   10、手写this、call、apply
  //   11、手写节流和防抖
  //   12、tcp三次握手过程
  //   13、tcp四次挥手过程
  //   14、webpack原理过程
  //   15、loader原理，手写loader
  //   16、plugin原理
  //   17、重绘和回流
  //   18、vue的双向绑定原理
  //   19、vue整个编制过程
  //   20、说一下diff


  // 基于Promise去实现一个延迟函数
  const delay = function(interval) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve(interval);
      }, interval);
    });
  };
  const tasks = [() => {
    return delay(1000);
  }, () => {
    return delay(1020);
  }, () => {
    return delay(1040);
  }, () => {
    return delay(1060);
  }, () => {
    return delay(1000);
  }, () => {
    return delay(1100);
  }, () => {
    return delay(1000);
  }];
  // Promise.all([delay(3000),delay(4000),delay(1000)]).then(res => console.log(res))


  // js实现ajax并发请求控制的两大解决方案
  /**
   * 保证顺序, 所有的都成功才认为成功
   * @param tasks 数组,包含若干个
   */
  /*
  function createRequest(tasks, pool = 5) {
    let results = [];
    let together = new Array(pool).fill(null), index = 0;
    together = together.map(() => {
      return new Promise(((resolve, reject) => {
        const run = function() {
          if(index >= tasks.length) {
            resolve(results)
            return
          }
          let old_index = index
          let task = tasks[index++]
          task().then(res => {
            results[old_index] = res
            run()
          }).catch(reason => {
            reject(reason)
          })
        }
        run()
      }))
    })
    return Promise.all(together).then(res => results)
  }

  createRequest(tasks, 2).then(res => {
    // 都成功了,整体才算成功,按顺序储存结果
    console.log(res);
  }).catch(reason => {
    // 只要有一个失败了, 整体就是失败
    console.log(reason);
  })
  */

  function createRequest(tasks, pool, callback) {
    if (typeof pool === 'function') {
      callback = pool;
      pool = 5;
    }
    if (typeof pool !== 'number') {
      pool = 5;
    }
    if (typeof callback !== 'function') callback = function() {
    };
  }


  createRequest(tasks, 2, (res) => {
    console.log(res);
  });


  const arr = [1,2,3,4,4,5,5,5,6,7]

  function unique(arr) {
    return arr.reduce((prev, curr) => {
      !prev.includes(curr) && prev.push(curr);
      return prev
    }, []);
  }

  // console.log(unique(arr));

  function unique1(arr) {
    return arr.filter((item, index, originalArray) => originalArray.indexOf(item) === index)
  }

  // console.log(unique1(arr));

  function unique2(arr) {
    return Array.from(new Set(arr))
  }



  const messageQueue = [];
  let sendMessage = (message) => {
    messageQueue.push(message)
    if(messageQueue.length === 1) {
      Promise.resolve().then(() => {
        console.log(messageQueue)
      })
    }
  }
  sendMessage('nan')
  sendMessage('fei')
  sendMessage('yan')

  let target = {};
  let source = { a: { b: { c: 1 } } };

  Object.assign(target, source);
  console.log(target);
</script>
</body>
</html>
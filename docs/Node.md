# Node

传统的服务器`Apache` `tomcat` `iis`

进程: 是操作系统分配资源和调度任务的基本单位 (工厂)
线程: 线程是进程中独立的一个任务单元 (工人)

```js
- 工厂的资源 -> 系统分配的内存（独立的一块内存）

- 工厂之间的相互独立 -> 进程之间相互独立

- 多个工人协作完成任务 -> 多个线程在进程中协作完成任务

- 工厂内有一个或多个工人 -> 一个进程由一个或多个线程组成

- 工人之间共享空间 -> 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）
```

tip: 

**单线程与多线程**，都是指**在一个进程内**的单和多

不同的进程之间也可以进行通信,不过代价很大

`node`单线程,非阻塞IO

### 浏览器是多进程的

- 浏览器是多进程的
- 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）
- 简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。


Javascript单线程的原因猜测是因为,如果js是多线程的一条指令让某个div隐藏一个指令让div显示,最后听谁的, 可能就产生矛盾了

**GUI渲染线程与JS引擎线程是互斥的**

事件驱动,非阻塞IO
1. 节约资源节约内存(node单线程不存在)
2. 节约上下文切换的时间(单线程不存在的)
3. 锁的问题, 并发资源的处理(node不存在的)
单线程带来的问题是: **如果这个线程出错了,那么整个服务就奔溃了**

在浏览器中UI线程和js线程是公用一个线程的,所以在js执行时ui是阻塞的,同时ui线程执行的时候,js线程也是阻塞的(验证方式是:在js中写个是循环,看看页面的内容还能出来不...)
### 3. 除了js线程和ui线程之外的其他线程
- 浏览器事件触发线程
- 定时触发器线程
- 异步HTTP请求线程

### 4. 任务队列
- 所有的同步任务都在主线程上执行, 形成一个执行栈.
- 于此同时会有一个**任务队列** 只要异步任务有了运行结果, 就会在任务对列之中放置一个事件
- 一旦执行栈中的所有同步任务执行完毕, 系统就会读取任务对列, 看看里面有哪些事件,哪些对应的异步任务, 于是结束等待状态, 进入执行栈开始执行
- 主线程不断的重复上面的第三步

下面说说Web Worker(多线程),但是: 1. 完全受主线程控制, 2.不能操作Dom

### 5. Event Loop
主线程从任务队列中读取事件, 这个过程是循环不断的,所以整个的这个机制又叫做事件轮询(Event loop)

![](https://user-gold-cdn.xitu.io/2019/7/23/16c1f3246e136f59?w=515&h=400&f=png&s=136004)
需要注意的点: 何时将事件放到异步队列中呢: 异步有了结果, 定时器到了一定的时间, 事件触发时
只有在栈中的同步任务执行完了才会执行event loop去队列中取

process.nextTick() // 是把这个回调函数放到执行栈的尾部
process.nextTick(function () {
    
})

## nextTick setimmediate 区别和联系
nextTick 把回调函数放在当前**执行栈**的底部

setimmediate 把回调函数放到**事件队列**的尾部  

nextTick 把回调函数放到当前执行栈的

![](https://user-gold-cdn.xitu.io/2019/7/24/16c1f910cd70f5ba?w=863&h=272&f=png&s=271820)
同步异步关注的是消息的通知方式取决于被调用者.
阻塞与非阻塞关注的是等待结果时的状态(指主线程)  取决于调用者

什么场合下应该考虑使用node框架
当应用程序需要处理大量的并发输入输出时, 在向客户端响应之前,应用程序并不需要进行大量的运算

- 聊天服务器

- 电子商务网站

  

**V8引擎最大的内存使用量是1.7G**

```js
console.log(process.cwd());  // 当前的项目路径
console.log(process.memoryUsage());  // 查看内存使用情况
{ rss: 21721088,  // 常驻内存
  heapTotal: 7159808, // 堆内存的总申请量
  heapUsed: 4311800,  // 已经使用的量
  external: 8224 }  //外部内存的使用量
```



### nextTick和 setImmediate 区别和联系

```js
nextTick 把回调函数放在当前执行栈的底部
setImmediate 把回调函数放到事件队列的尾部
```





























